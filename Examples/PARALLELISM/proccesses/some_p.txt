Пакет multiprocessing — це пакет для виконання коду в окремих процесах з інтерфейсом подібним до інтерфейсу пакета threading.
(Global Interpreter Lock) і той факт, що threading API не дозволяє розпаралелювати CPU-bound завдання.
Для використання процесів (from multiprocessing import Process) декількома способами:
1) У процесі створення екземпляра класу Process іменованого аргументу target передати функцію, яка буде виконуватися в окремому процесі
2) Реалізувати похідний клас від класу Process та перевизначити метод run

Contexts and start methods
Залежно від платформи multiprocessing підтримує 3 способи створення нового процесу:
spawn — запускає новий процес Python, успадковуються лише ресурси, необхідні для запуску run(). Є в Unix і Windows. Є за замовчуванням для Windows і macOS.
fork — дочірній процес, що є точною копією батьківського (включаючи всі потоки), доступний тільки на Unix. За замовчуванням використовується на Unix. Зробити безпечний fork досить проблематично і це може бути причиною неочевидних проблем.
forkserver — створюється процес-фабрика (сервер для породження процесів на запит). Наслідуються тільки необхідні ресурси, що використовуються fork для запуску нового процесу, але завдяки однопотоковій реалізації процесу-фабрики, це робиться безпечно. Доступний тільки на Unix платформах із підтримкою передачі файлових дескрипторів через pipes (що може суперечити безпековій політиці на багатьох системах).
Для вибору методу використовується multiprocessing.set_start_method(method):
multiprocessing.set_start_method('forkserver')

Механізми обміну даними залежать від ОС (Операційної Системи). Найбільш універсальний — файли. Але ви також можете скористатися мережевими інтерфейсами (localhost), примітивами на основі мережевих інтерфейсів (pipe) та загальною пам'яттю, де це можливо.
У будь-якому випадку, крім загальної пам'яті, для обміну даними між процесами всі об'єкти серіалізуються та десеріалізуються. Цей додатковий крок створює навантаження на CPU.
Найшвидшим та економнішим з погляду ресурсів способом обміну даними є спільна пам'ять.

Загальна пам'ять підтримується не всіма операційними системами та може бути заборонена політикою безпеки.
Для обчислення обсягу пам'яті обов'язково треба вказати тип даних, який буде використовуватись, та кількість елементів для складних типів. Крім того, механізми обмеження доступу до загального ресурсу також треба забезпечити самостійно, інакше дані можна зіпсувати при спробі одночасного доступу для зміни із різних процесів.

Більш вимогливий до ресурсів, але й зручніший у використанні механізм обміну даними між процесами — це Менеджер ресурсів. Основна перевага — можливість працювати по всій мережі та реалізувати розподілені обчислення між кількома комп'ютерами в одній мережі, реалізація Python-like списків та словників.
Недоліки:
Необхідність синхронізувати доступ до загальних ресурсів;
Обмеження на типи, що підтримуються;
Складне API.
Проксі-об'єкти Manager не можуть поширювати зміни, внесені до об'єктів, що змінюються всередині контейнера.

Механізм каналів реалізований поверх сокетів (мережеві інтерфейси) і дає зручніший інтерфейс. 
Канал являє собою пару об'єктів — кінці каналу. Ви можете асинхронно писати в канал (надсилати повідомлення) та читати з каналу (отримувати повідомлення на іншому кінці). Повідомлень у каналі може бути більше одного одночасно і порядок повідомлень гарантується. Канали реалізують обмін між двома процесами, не можна використовувати один і той же кінець каналу в кількох процесах.
У канал можна відправити будь-який тип даних, який можна перетворити на byte-рядок за допомогою pickle. Не можна надсилати функції або інші об'єкти, які не серіалізуються.

Черги завдань
Окремий механізм обміну даними між процесами — це черги. Черга дозволяє "покласти" дані для обробки одному із "працівників" і потім проконтролювати, коли "працівник" завершив обробку. Черги — це засіб комунікації між одним відправником, найчастіше його називають master, та будь-якою кількістю одержувачів повідомлень, часто їх називають slave або у більш нейтральному тоні — worker.
Об'єктів у черзі може бути більше одного. Черга може бути обмежена за розміром, якщо це потрібно. Черга гарантує порядок повідомлень та неможливість отримання одного повідомлення кількома одержувачами.
Черги в Python реалізовані у класах Queue та JoinableQueue.
Для контролю процесу завершення завдань можна використовувати клас JoinableQueue.

--------------------------------------------
Створення процесів за допомогою пакета multiprocessing
Для спрощення комунікації у пакеті multiprocessing є клас, який реалізує пул процесів за аналогією з concurrent.futures.
Основне застосування — це виконання паралельно однакових завдань із деяким набором однотипних вхідних даних.



































